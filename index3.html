<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <title>three.js 统一坐标轴拖动+轴辅助器 Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background: #0e0f12; overflow: hidden; }
    #hud {
      position: fixed; left: 10px; top: 10px; z-index: 10;
      background: rgba(0,0,0,0.5); color: #e8e8e8; padding: 10px 12px; border-radius: 8px;
      font: 12px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Microsoft YaHei", sans-serif;
      user-select: none;
    }
    #hud b { color: #fff; }
    a { color: #7dd3fc; text-decoration: none; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="hud">
    <div><b>操作</b></div>
    <div>• 点击一个点选中，然后沿彩色轴拖动（坐标轴统一为世界方向）</div>
    <div>• Q：世界/本地 | W/E/R：移动/旋转/缩放</div>
    <div>• X/Y/Z：开关各轴 | +/-：调整手柄尺寸 | Esc：取消选择</div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e0f12);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(6, 6, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x2a2a2a, 0.7);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    const grid = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
    if (Array.isArray(grid.material)) {
      grid.material.forEach(m => { m.transparent = true; m.opacity = 0.35; });
    } else {
      grid.material.transparent = true;
      grid.material.opacity = 0.35;
    }
    scene.add(grid);

    const pointsGroup = new THREE.Group();
    scene.add(pointsGroup);

    const pointGeom = new THREE.SphereGeometry(0.08, 16, 16);
    const baseColor = new THREE.Color('#57b6ff');

    const COUNT = 40;
    for (let i = 0; i < COUNT; i++) {
      const mat = new THREE.MeshStandardMaterial({
        color: baseColor.clone(),
        metalness: 0.1,
        roughness: 0.6
      });
      const point = new THREE.Mesh(pointGeom, mat);
      point.position.set(
        THREE.MathUtils.randFloatSpread(10),
        THREE.MathUtils.randFloatSpread(6) + 1,
        THREE.MathUtils.randFloatSpread(10)
      );
      // **取消随机旋转，保持点无旋转，方便统一坐标轴**
      point.rotation.set(0, 0, 0);

      point.userData.baseColor = point.material.color.getHex();
      point.name = `Point_${i}`;
      pointsGroup.add(point);
    }

    // TransformControls
    const gizmo = new TransformControls(camera, renderer.domElement);
    gizmo.setMode('translate');
    gizmo.setSpace('local'); // 这里仍用 local，后面强制旋转为单位四元数
    gizmo.setSize(0.9);
    scene.add(gizmo);

    gizmo.addEventListener('dragging-changed', (e) => {
      orbit.enabled = !e.value;
    });

    // 轴辅助器
    const axesHelper = new THREE.AxesHelper(0.5);
    axesHelper.visible = false;
    scene.add(axesHelper);

    // 选中点
    let selected = null;
    function setSelected(obj) {
      if (selected === obj) return;

      if (selected) {
        selected.material.color.setHex(selected.userData.baseColor);
      }
      selected = obj || null;

      if (selected) {
        selected.material.color.set('#ffcc00');
        gizmo.attach(selected);

        // 轴辅助器放到点旁边，显示并重置旋转（固定方向）
        axesHelper.position.copy(selected.position);
        axesHelper.visible = true;
        axesHelper.rotation.set(0, 0, 0);
      } else {
        gizmo.detach();
        axesHelper.visible = false;
      }
    }

    // 射线拾取
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function updatePointerFromEvent(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    renderer.domElement.addEventListener('pointerdown', (event) => {
      if (gizmo.dragging) return;

      updatePointerFromEvent(event);
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(pointsGroup.children, false);
      if (hits.length) {
        setSelected(hits[0].object);
      } else {
        setSelected(null);
      }
    });

    renderer.domElement.addEventListener('pointermove', (event) => {
      if (gizmo.dragging) return;
      updatePointerFromEvent(event);
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(pointsGroup.children, false);
      renderer.domElement.style.cursor = hits.length ? 'pointer' : 'default';
    });

    // 强制 TransformControls 的旋转为单位四元数，保持坐标轴方向不变
    // 监听每帧更新
    function fixGizmoRotation() {
      if (gizmo.object) {
        // 只在拖动时强制旋转为单位四元数，防止坐标轴旋转
        if (gizmo.dragging) {
          gizmo.object.quaternion.identity();
        }
      }
    }

    // 键盘快捷键
    window.addEventListener('keydown', (event) => {
      const k = event.key.toLowerCase();
      if (k === 'q') gizmo.setSpace(gizmo.space === 'local' ? 'world' : 'local');
      if (k === 'w') gizmo.setMode('translate');
      if (k === 'e') gizmo.setMode('rotate');
      if (k === 'r') gizmo.setMode('scale');

      if (k === 'x') gizmo.showX = !gizmo.showX;
      if (k === 'y') gizmo.showY = !gizmo.showY;
      if (k === 'z') gizmo.showZ = !gizmo.showZ;

      if (k === 'escape') setSelected(null);

      if (k === '+' || k === '=') gizmo.setSize(gizmo.size + 0.1);
      if (k === '-' || k === '_') gizmo.setSize(Math.max(0.1, gizmo.size - 0.1));
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    function animate() {
      orbit.update();
      fixGizmoRotation();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>